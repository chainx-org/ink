// Copyright 2018-2019 Parity Technologies (UK) Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use derive_more::From;
use proc_macro2::TokenStream as TokenStream2;
use quote::{
    quote,
    quote_spanned,
};

use crate::{
    codegen::{
        cross_calling::CrossCallingConflictCfg,
        env_types::EnvTypesImports,
        GenerateCode,
        GenerateCodeUsing,
    },
    ir,
    ir::utils,
};

/// Generates helper definitions for the user defined event definitions.
///
/// These include:
///
/// - `Event` enum that unifies all user defined event definitions
/// - `EmitEvent` helper trait to allow for `emit_event` in messages and constructors
/// - `Topics` implementations for all user provided event definitions
///
/// # Note
///
/// All of this code should be generated inside the `__ink_private` module.
#[derive(From)]
pub struct EventHelpers<'a> {
    /// The contract to generate code for.
    contract: &'a ir::Contract,
}

impl<'a> GenerateCodeUsing for EventHelpers<'a> {
    fn contract(&self) -> &ir::Contract {
        self.contract
    }
}

impl GenerateCode for EventHelpers<'_> {
    fn generate_code(&self) -> TokenStream2 {
        let conflic_depedency_cfg = self.generate_code_using::<CrossCallingConflictCfg>();
        let topics_impls = self.generate_topics_impls();
        let event_enum = self.generate_event_enum();
        let emit_event_trait = self.generate_emit_event_trait();
        let event_imports = self.generate_code_using::<EventImports>();
        let env_imports = self.generate_code_using::<EnvTypesImports>();

        // Generate no code if there are no user defined events.
        if self.contract.events.is_empty() {
            return quote! {}
        }

        quote! {
            #conflic_depedency_cfg
            mod __ink_events {
                #env_imports
                #event_imports

                #(
                    #topics_impls
                )*

                #event_enum
                #emit_event_trait
            }
            #conflic_depedency_cfg
            pub use __ink_events::{EmitEvent, Event};
        }
    }
}

impl EventHelpers<'_> {
    fn generate_emit_event_trait(&self) -> TokenStream2 {
        quote! {
            /// Implemented by contracts in order to override `env().emit_event(..)`
            /// syntax for emitting of ink! contract events.
            ///
            /// # Dev Note
            ///
            /// Normally we'd try to define traits like these in the compagnion
            /// `ink_lang` crate, however, due to Rust's orphan rules we must
            /// define this trait here.
            pub trait EmitEvent {
                /// The base event type.
                ///
                /// # Note
                ///
                /// This is the event enum that is generated by the ink! macro.
                type Event;

                /// Emits an event that can be trivially converted into the base event.
                fn emit_event<E>(self, event: E)
                where
                    E: Into<Self::Event>;
            }

            const _: () = {
                impl<'a> EmitEvent for ink_lang::EnvAccess<'a, EnvTypes> {
                    type Event = Event;

                    fn emit_event<E>(self, event: E)
                    where
                        E: Into<Self::Event>,
                    {
                        ink_lang::EnvAccess::<EnvTypes>::emit_event(self, event.into())
                    }
                }
            };
        }
    }

    fn generate_event_enum(&self) -> TokenStream2 {
        let event_idents = self
            .contract
            .events
            .iter()
            .map(|item_event| &item_event.ident)
            .collect::<Vec<_>>();

        #[cfg(feature = "old-codec")]
        use old_scale::Encode;
        #[cfg(not(feature = "old-codec"))]
        use scale::Encode;

        quote! {
            #[derive(Encode)]
            pub enum Event {
                #( #event_idents(#event_idents), )*
            }

            #(
                impl From<#event_idents> for Event {
                    fn from(event: #event_idents) -> Self {
                        Event::#event_idents(event)
                    }
                }
            )*

            impl ink_core::env::Topics<EnvTypes> for Event {
                fn topics(&self) -> &'static [Hash] {
                    match self {
                        #(
                            Event::#event_idents(event) => event.topics(),
                        )*
                    }
                }
            }
        }
    }

    fn generate_topics_impls<'a>(&'a self) -> impl Iterator<Item = TokenStream2> + 'a {
        self.contract.events.iter().map(|item_event| {
            let span = item_event.span();
            let ident = &item_event.ident;

            quote_spanned!(span =>
                impl ink_core::env::Topics<EnvTypes> for #ident {
                    fn topics(&self) -> &'static [Hash] {
                        &[]
                    }
                }
            )
        })
    }
}

/// Generates the user provided event `struct` definitions.
///
/// This includes
///
/// - making all fields `pub`
/// - strip `#[ink(..)]` attributes
/// - add `#[derive(scale::Encode)]`
///
/// # Note
///
/// The code shall be generated on the ink! module root.
#[derive(From)]
pub struct EventStructs<'a> {
    /// The contract to generate code for.
    contract: &'a ir::Contract,
}

impl<'a> GenerateCodeUsing for EventStructs<'a> {
    fn contract(&self) -> &ir::Contract {
        self.contract
    }
}

impl EventStructs<'_> {
    fn generate_event_structs<'a>(&'a self) -> impl Iterator<Item = TokenStream2> + 'a {
        self.contract.events.iter().map(move |item_event| {
            let conflic_depedency_cfg =
                self.generate_code_using::<CrossCallingConflictCfg>();

            let span = item_event.span();
            let ident = &item_event.ident;
            let attrs = utils::filter_non_ink_attributes(&item_event.attrs);
            let mut fields = item_event.fields.clone();
            fields.named.iter_mut().for_each(|field| {
                // Set visibility of all fields to `pub`.
                field.vis = syn::Visibility::Public(syn::VisPublic {
                    pub_token: Default::default(),
                });
                // Only re-generate non-ink! attributes.
                field
                    .attrs
                    .retain(|attr| !ir::utils::is_ink_attribute(attr))
            });

            quote_spanned!(span =>
                #conflic_depedency_cfg
                #(#attrs)*
                #[derive(Encode)]
                pub struct #ident
                    #fields
            )
        })
    }
}

impl GenerateCode for EventStructs<'_> {
    fn generate_code(&self) -> TokenStream2 {
        // Generate no code if there are no user defined events.
        if self.contract.events.is_empty() {
            return quote! {}
        }

        let event_structs = self.generate_event_structs();
        quote! {
            #(#event_structs)*
        }
    }
}

/// Generates code to generate the event imports mainly used by
/// definitions inside of the generated `__ink_private` module.
///
/// # Note
///
/// The generated code can be used from arbitrary positions within
/// the `__ink_private` module.
#[derive(From)]
pub struct EventImports<'a> {
    /// The contract to generate code for.
    contract: &'a ir::Contract,
}

impl<'a> GenerateCodeUsing for EventImports<'a> {
    fn contract(&self) -> &ir::Contract {
        self.contract
    }
}

impl GenerateCode for EventImports<'_> {
    fn generate_code(&self) -> TokenStream2 {
        if self.contract.events.is_empty() {
            return quote! {}
        }

        let conflic_depedency_cfg = self.generate_code_using::<CrossCallingConflictCfg>();
        let event_idents = self
            .contract
            .events
            .iter()
            .map(|item_event| &item_event.ident);

        quote! {
            #conflic_depedency_cfg
            pub use super::{
                #( #event_idents ),*
            };
        }
    }
}
